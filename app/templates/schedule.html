<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Система расписания</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <!-- Навигационные ссылки -->
    <div style="text-align: center; margin-bottom: 20px;">
        <a href="{{ url_for('main_index') }}" style="display: inline-block; margin: 0 10px; padding: 8px 16px; text-decoration: none; color: #3498db; border: 1px solid #3498db; border-radius: 4px; transition: background-color 0.3s ease, color 0.3s ease;">Главная</a>
        <a href="{{ url_for('admin_panel') }}" style="display: inline-block; margin: 0 10px; padding: 8px 16px; text-decoration: none; color: #3498db; border: 1px solid #3498db; border-radius: 4px; transition: background-color 0.3s ease, color 0.3s ease;">Админ-панель</a>
    </div>
    <div id="controls-container">
        <label for="shift-selector">Выберите смену:</label>
        <select id="shift-selector">
            <option value="">-- Выберите смену --</option>
        </select>
        <!-- НОВОЕ: Поле для выбора даты -->
        <label for="date-selector">Выберите дату:</label>
        <input type="date" id="date-selector" />
        <button id="apply-date-btn">Применить дату</button>
        <button id="permanent-schedule-btn">Постоянное расписание</button>
        <!-- Новый контейнер для контролов загрузки -->
        <div id="upload-controls">
            <label for="file-hours">Файл часов (Класс-Предмет):</label>
            <input type="file" id="file-hours" accept=".xlsx, .xls" />
            <label for="file-teachers">Файл нагрузки (Учитель-Предмет-Класс):</label>
            <input type="file" id="file-teachers" accept=".xlsx, .xls" />
            <button id="upload-btn">Загрузить и Обработать</button>
        </div>
        <!-- НОВЫЙ контейнер для контролов экспорта и очистки -->
        <div id="export-controls">
            <button id="export-btn">Экспорт в Excel (список)</button>
            <button id="export-formatted-btn">Экспорт в Excel (таблица)</button> <!-- НОВАЯ КНОПКА -->
            <button id="clear-schedule-btn">Очистить расписание (смена)</button>
            <button id="clear-db-btn">Очистить БД (всё)</button>
        </div>
        <div id="upload-status"></div>
    </div>
    <div id="main-content">
        <div id="schedule-container">
            <h2>Расписание</h2>
            <div id="schedule-table-container">
                <table id="schedule-table">
                    <thead>
                        <tr id="schedule-headers">
                            <!-- Содержимое будет заполнено JS -->
                        </tr>
                    </thead>
                    <tbody id="schedule-body">
                        <!-- Содержимое будет заполнено JS -->
                    </tbody>
                </table>
            </div>
        </div>
        <div id="chatbot-container">
            <div id="chat-messages">
                <!-- Сообщения чат-бота будут добавляться сюда -->
                <div class="message bot-message">Привет! Я ваш помощник по расписанию. Выберите смену и дату.</div>
            </div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Введите команду...">
                <button id="send-button">Отправить</button>
            </div>
        </div>
    </div>
    <!-- Модальное окно для редактирования -->
    <div id="edit-modal">
        <div class="modal-content">
            <h3>Редактировать урок</h3>
            <form id="edit-form">
                <input type="hidden" id="edit-lesson-id">
                <label for="edit-subject">Предмет:</label>
                <select id="edit-subject" required></select>
                <label for="edit-teacher">Учитель:</label>
                <select id="edit-teacher" required></select>
                <label for="edit-subgroup">Подгруппа:</label>
                <select id="edit-subgroup" required></select>
                <label for="edit-room">Кабинет:</label>
                <select id="edit-room" required></select>
                <!-- Поля для дня и урока (для возможности их изменения) -->
                <label for="edit-day">День недели:</label>
                <select id="edit-day" required>
                    <option value="0">Понедельник</option>
                    <option value="1">Вторник</option>
                    <option value="2">Среда</option>
                    <option value="3">Четверг</option>
                    <option value="4">Пятница</option>
                </select>
                <label for="edit-slot">Номер урока:</label>
                <select id="edit-slot" required>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
                <div class="modal-buttons">
                    <button type="button" id="cancel-edit">Отмена</button>
                    <button type="submit" id="save-edit">Сохранить</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- Глобальные переменные ---
        let scheduleData = []; // Базовое расписание для дня недели
        let temporaryChangesData = []; // Временные изменения для выбранной даты
        let teachersList = [];
        let subjectsList = [];
        let classesList = []; // Теперь содержит список классов для выбранной смены
        let subgroupsList = [];
        let roomsList = [];
        let shiftsList = []; // Список смен
        let currentShift = null; // Выбранная смена
        let selectedDate = null; // Выбранная дата
        let currentHighlightedTeacherId = null;
        let currentHighlightedRoomId = null; // НОВОЕ: для подсветки кабинетов
        // НОВОЕ: для требований
        let classSubjectRequirementsList = []; // Список требований класс-предмет
        // --- НОВОЕ: для отслеживания текущего класса в модальном окне ---
        let currentClassId = null;
        // --- Вспомогательные функции ---
        function getDayName(dayIndex) {
            const days = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт'];
            return days[dayIndex] || '';
        }
        function getDayNameFull(dayIndex) {
            const days = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница'];
            return days[dayIndex] || '';
        }
        function getDayIndex(dayName) {
            const days = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт'];
            return days.indexOf(dayName);
        }
        // --- Загрузка данных ---
        async function loadShifts() {
            try {
                const shiftsResponse = await fetch('/api/shifts');
                shiftsList = await shiftsResponse.json();
                const shiftSelector = document.getElementById('shift-selector');
                shiftSelector.innerHTML = '<option value="">-- Выберите смену --</option>';
                shiftsList.forEach(shift => {
                    const option = document.createElement('option');
                    option.value = shift.id;
                    option.textContent = shift.name;
                    shiftSelector.appendChild(option);
                });
                // Добавим обработчик изменения смены
                shiftSelector.addEventListener('change', (e) => {
                    currentShift = parseInt(e.target.value) || null;
                    if (currentShift) {
                        if (selectedDate) {
                            loadScheduleDataForDate(selectedDate, currentShift); // Загружаем данные для выбранной смены и даты
                        } else {
                            loadScheduleData(currentShift); // Загружаем базовое расписание для выбранной смены
                        }
                        // НОВОЕ: Загружаем и требования
                        loadClassSubjectRequirements(); // Загружаем требования при выборе смены
                    } else {
                        // Очистить таблицу, если смена не выбрана
                        document.getElementById('schedule-headers').innerHTML = '';
                        document.getElementById('schedule-body').innerHTML = '';
                        addChatMessage("Смена не выбрана.", 'bot');
                    }
                });
            } catch (error) {
                console.error('Ошибка загрузки смен:', error);
                addChatMessage(`Ошибка загрузки смен: ${error.message}`, 'bot');
            }
        }
        async function loadClassSubjectRequirements() {
            try {
                const response = await fetch('/api/class_subject_requirements');
                classSubjectRequirementsList = await response.json();
            } catch (error) {
                console.error('Ошибка загрузки требований по класс-предмет:', error);
                // Можно продолжить с пустым списком, но валидация может работать некорректно
                classSubjectRequirementsList = [];
            }
        }
        async function loadScheduleData(shiftId) {
            try {
                // Загрузка справочников (учителя, предметы и т.д.)
                // Загружаем все, но используем только для выбранной смены
                const teachersResponse = await fetch('/api/teachers');
                teachersList = await teachersResponse.json();
                const subjectsResponse = await fetch('/api/subjects');
                subjectsList = await subjectsResponse.json();
                // Загрузка классов для выбранной смены
                const classesResponse = await fetch(`/api/classes?shift=${shiftId}`);
                classesList = await classesResponse.json();
                const subgroupsResponse = await fetch('/api/subgroups');
                subgroupsList = await subgroupsResponse.json();
                const roomsResponse = await fetch('/api/rooms');
                roomsList = await roomsResponse.json();
                // Загрузка уроков для выбранной смены
                const lessonsResponse = await fetch(`/api/lessons?shift=${shiftId}`);
                scheduleData = await lessonsResponse.json();
                // Очищаем временные изменения, так как дата не выбрана
                temporaryChangesData = [];
                renderSchedule();
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
                addChatMessage(`Ошибка загрузки данных: ${error.message}`, 'bot');
            }
        }
        // --- НОВАЯ ФУНКЦИЯ: Загрузка данных для конкретной даты ---
        async function loadScheduleDataForDate(date, shiftId) {
            try {
                // Загрузка справочников (учителя, предметы и т.д.)
                const teachersResponse = await fetch('/api/teachers');
                teachersList = await teachersResponse.json();
                const subjectsResponse = await fetch('/api/subjects');
                subjectsList = await subjectsResponse.json();
                // Загрузка классов для выбранной смены
                const classesResponse = await fetch(`/api/classes?shift=${shiftId}`);
                classesList = await classesResponse.json();
                const subgroupsResponse = await fetch('/api/subgroups');
                subgroupsList = await subgroupsResponse.json();
                const roomsResponse = await fetch('/api/rooms');
                roomsList = await roomsResponse.json();

                // Получаем день недели из выбранной даты
                const dateObj = new Date(date);
                const dayOfWeek = dateObj.getDay(); // 0=Вс, 1=Пн, ..., 6=Сб. Преобразуем к 0=Пн, ..., 4=Пт.
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    addChatMessage("Выбранная дата - выходной день.", 'bot');
                    scheduleData = []; // Очищаем базовое расписание
                    temporaryChangesData = []; // Очищаем временные изменения
                    renderSchedule(); // Перерисуем пустую таблицу или с пометкой
                    return;
                }
                const dayIndex = dayOfWeek - 1; // Преобразуем к 0-4

                // Загрузка БАЗОВОГО расписания для дня недели выбранной даты и смены
                const lessonsResponse = await fetch(`/api/lessons?shift=${shiftId}`);
                const allLessons = await lessonsResponse.json();
                // Фильтруем уроки по дню недели
                scheduleData = allLessons.filter(lesson => lesson.day_of_week === dayIndex);

                // Загрузка ВРЕМЕННЫХ ИЗМЕНЕНИЙ для выбранной даты
                const tempChangesResponse = await fetch(`/api/temporary_changes?date=${date}`);
                temporaryChangesData = await tempChangesResponse.json();

                renderSchedule();
            } catch (error) {
                console.error('Ошибка загрузки данных для даты:', error);
                addChatMessage(`Ошибка загрузки данных для ${date}: ${error.message}`, 'bot');
            }
        }
        // --- Отображение расписания (новая структура) ---
        function renderSchedule() {
            const headersRow = document.getElementById('schedule-headers');
            const tbody = document.getElementById('schedule-body');
            headersRow.innerHTML = ''; // Очистить перед рендерингом
            tbody.innerHTML = ''; // Очистить перед рендерингом
            // Создание заголовков (столбцы = классы)
            const headerDayCell = document.createElement('th');
            headerDayCell.textContent = 'День';
            headerDayCell.style.position = 'sticky';
            headerDayCell.style.left = '0';
            headerDayCell.style.zIndex = '10';
            headerDayCell.style.backgroundColor = '#f2f2f2'; // Убедимся, что фон заголовка виден
            headersRow.appendChild(headerDayCell);
            const headerLessonNumCell = document.createElement('th');
            headerLessonNumCell.textContent = 'Урок';
            headerLessonNumCell.style.position = 'sticky';
            headerLessonNumCell.style.left = '70px'; // Ширина первого столбца + небольшой запас
            headerLessonNumCell.style.zIndex = '10';
            headerLessonNumCell.style.backgroundColor = '#f2f2f2'; // Убедимся, что фон заголовка виден
            headersRow.appendChild(headerLessonNumCell);
            classesList.forEach(cls => {
                const headerCell = document.createElement('th');
                headerCell.textContent = cls.name;
                headersRow.appendChild(headerCell);
            });
            // Предположим, у нас 6 пар в день
            const maxLessons = 6;
            // Группируем ВРЕМЕННЫЕ ИЗМЕНЕНИЯ по original_lesson_id для быстрого доступа
            const tempChangesByLessonId = {};
            temporaryChangesData.forEach(change => {
                tempChangesByLessonId[change.original_lesson_id] = change;
            });
            // Заполняем строки (уроки) - 7 строк (день + 6 уроков)
            const dayNameFull = selectedDate ? new Date(selectedDate).toLocaleDateString('ru-RU', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }) : getDayNameFull(0); // Показываем выбранную дату или день недели
            // Строка заголовка дня
            const dayHeaderRow = document.createElement('tr');
            const dayHeaderCell = document.createElement('td');
            dayHeaderCell.textContent = dayNameFull;
            dayHeaderCell.className = 'day-header-cell';
            dayHeaderCell.rowSpan = maxLessons + 1; // Объединяет 7 строк: 1 день + 6 уроков
            dayHeaderRow.appendChild(dayHeaderCell);
            // Второй столбец в строке заголовка дня - пустой
            const emptyHeaderCell = document.createElement('td');
            emptyHeaderCell.textContent = '';
            emptyHeaderCell.className = 'lesson-number-header'; // Добавим класс для стилизации
            dayHeaderRow.appendChild(emptyHeaderCell);
            // Вместо этого добавляем пустые ячейки, соответствующие количеству классов
            classesList.forEach(cls => {
                const emptyCell = document.createElement('td');
                emptyCell.textContent = ''; // Оставляем пустым
                dayHeaderRow.appendChild(emptyCell);
            });
            tbody.appendChild(dayHeaderRow);
            // Строки номеров уроков
            for (let lessonNum = 1; lessonNum <= maxLessons; lessonNum++) {
                const row = document.createElement('tr');
                // Ячейка с номером урока
                const lessonNumCell = document.createElement('td');
                lessonNumCell.textContent = lessonNum;
                lessonNumCell.className = 'lesson-number-header';
                row.appendChild(lessonNumCell);
                // Ячейки для каждого класса
                classesList.forEach(cls => {
                    const cell = document.createElement('td');
                    cell.className = 'lesson-cell';
                    cell.dataset.day = selectedDate ? new Date(selectedDate).getDay() - 1 : 0; // Используем день недели из даты, если выбрана
                    cell.dataset.lessonNumber = lessonNum;
                    cell.dataset.classId = cls.id; // ID класса для этой ячейки
                    // Найдем уроки для этого класса, дня и номера урока из базового расписания
                    const lessonsInSlot = scheduleData.filter(lesson => {
                        const subgroup = subgroupsList.find(sg => sg.id === lesson.subgroup_id);
                        return subgroup && subgroup.class_id === cls.id && lesson.lesson_number === lessonNum;
                    });

                    if (lessonsInSlot.length > 0) {
                        // Создаём контейнер для уроков
                        const lessonsContainer = document.createElement('div');
                        lessonsContainer.className = 'lessons-container';
                        lessonsInSlot.forEach(lesson => {
                            const lessonDiv = document.createElement('div');
                            // Проверим, есть ли временное изменение для этого урока на выбранную дату
                            const tempChange = tempChangesByLessonId[lesson.id];
                            if (tempChange) {
                                // --- Применяем изменения ---
                                // Выбираем данные из временного изменения или оставляем оригинальные
                                const displaySubjectId = lesson.subject_id; // Предмет не меняется
                                const displayTeacherId = tempChange.new_teacher_id || lesson.teacher_id;
                                const displayRoomId = tempChange.new_room_id || lesson.room_id;
                                const displayDay = tempChange.new_day_of_week !== undefined ? tempChange.new_day_of_week : lesson.day_of_week;
                                const displaySlot = tempChange.new_lesson_number !== undefined ? tempChange.new_lesson_number : lesson.lesson_number;

                                // Найти соответствующие названия из списков
                                const subject = subjectsList.find(s => s.id === displaySubjectId);
                                const teacher = teachersList.find(t => t.id === displayTeacherId);
                                const subgroup = subgroupsList.find(sg => sg.id === lesson.subgroup_id);
                                const room = roomsList.find(r => r.id === displayRoomId);

                                // Отображение: Предмет, Кабинет, Учитель + пометка об изменении
                                lessonDiv.className = 'lesson-details';
                                lessonDiv.dataset.lessonId = lesson.id; // Для редактирования
                                lessonDiv.dataset.subgroupId = lesson.subgroup_id; // Добавим ID подгруппы
                                lessonDiv.dataset.originalLessonId = lesson.id; // Для временных изменений
                                lessonDiv.dataset.date = selectedDate; // Для временных изменений
                                // Подсветка для временного изменения
                                if (tempChange.change_type === 'substitution') {
                                    lessonDiv.style.backgroundColor = '#ffeb3b'; // Жёлтый для замены
                                } else if (tempChange.change_type === 'movement') {
                                    lessonDiv.style.backgroundColor = '#4caf50'; // Зелёный для переноса
                                } else if (tempChange.change_type === 'cancellation') {
                                    lessonDiv.style.backgroundColor = '#f44336'; // Красный для отмены
                                    lessonDiv.style.opacity = '0.6'; // Сделать полупрозрачным
                                }
                                lessonDiv.innerHTML = `
                                    <div class="subject-name" data-subject-id="${displaySubjectId}">${subject ? subject.name : 'N/A'}</div>
                                    <div class="room-name" data-room-id="${displayRoomId}">${room ? room.name : 'N/A'}</div>
                                    <div class="teacher-name" data-teacher-id="${displayTeacherId}">${teacher ? teacher.name : 'N/A'}</div>
                                    <div class="change-type">${tempChange.change_type === 'substitution' ? 'Замена' : tempChange.change_type === 'movement' ? 'Перенос' : 'Отмена'}</div>
                                    <div class="change-date">${selectedDate}</div> <!-- НОВОЕ: Показываем дату изменения -->
                                `;
                            } else {
                                // --- Без изменений ---
                                // Найти соответствующие названия из списков
                                const teacher = teachersList.find(t => t.id === lesson.teacher_id);
                                const subject = subjectsList.find(s => s.id === lesson.subject_id);
                                const subgroup = subgroupsList.find(sg => sg.id === lesson.subgroup_id);
                                const room = roomsList.find(r => r.id === lesson.room_id);
                                // Отображение: Предмет, Кабинет, Учитель
                                lessonDiv.className = 'lesson-details';
                                lessonDiv.dataset.lessonId = lesson.id; // Для редактирования
                                lessonDiv.dataset.subgroupId = lesson.subgroup_id; // Добавим ID подгруппы
                                lessonDiv.dataset.originalLessonId = lesson.id; // Для временных изменений
                                lessonDiv.dataset.date = selectedDate; // Для временных изменений
                                lessonDiv.innerHTML = `
                                    <div class="subject-name" data-subject-id="${lesson.subject_id}">${subject ? subject.name : 'N/A'}</div>
                                    <div class="room-name" data-room-id="${lesson.room_id}">${room ? room.name : 'N/A'}</div>
                                    <div class="teacher-name" data-teacher-id="${lesson.teacher_id}">${teacher ? teacher.name : 'N/A'}</div>
                                `;
                            }
                            lessonsContainer.appendChild(lessonDiv);
                        });
                        cell.appendChild(lessonsContainer);
                    } else {
                        // Пустая ячейка
                        cell.textContent = 'Нет урока';
                        cell.style.backgroundColor = '#f9f9f9';
                        // Добавим атрибуты для потенциального создания урока на эту дату
                        cell.dataset.originalLessonId = ''; // Пока пусто
                        cell.dataset.date = selectedDate;
                    }
                    row.appendChild(cell);
                });
                tbody.appendChild(row);
            }
            attachEventListeners();
        }
        // --- Подсветка учителя (новая логика) ---
        function highlightTeacher(teacherId) {
            // Сброс предыдущей подсветки учителя
            if (currentHighlightedTeacherId !== null) {
                document.querySelectorAll(`.teacher-name[data-teacher-id="${currentHighlightedTeacherId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.remove('highlighted-teacher');
                });
            }
            // Сброс подсветки кабинета при подсветке учителя
            if (currentHighlightedRoomId !== null) {
                 document.querySelectorAll(`.room-name[data-room-id="${currentHighlightedRoomId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.remove('highlighted-room');
                });
                currentHighlightedRoomId = null;
            }
            // Установка новой подсветки учителя
            if (teacherId) {
                document.querySelectorAll(`.teacher-name[data-teacher-id="${teacherId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.add('highlighted-teacher');
                });
                currentHighlightedTeacherId = teacherId;
            } else {
                currentHighlightedTeacherId = null;
            }
        }
        // --- Подсветка кабинета (новая логика) ---
        function highlightRoom(roomId) {
            // Сброс предыдущей подсветки кабинета
            if (currentHighlightedRoomId !== null) {
                document.querySelectorAll(`.room-name[data-room-id="${currentHighlightedRoomId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.remove('highlighted-room');
                });
            }
            // Сброс подсветки учителя при подсветке кабинета
            if (currentHighlightedTeacherId !== null) {
                 document.querySelectorAll(`.teacher-name[data-teacher-id="${currentHighlightedTeacherId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.remove('highlighted-teacher');
                });
                currentHighlightedTeacherId = null;
            }
            // Установка новой подсветки кабинета
            if (roomId) {
                document.querySelectorAll(`.room-name[data-room-id="${roomId}"]`).forEach(el => {
                    el.closest('.lesson-details').classList.add('highlighted-room');
                });
                currentHighlightedRoomId = roomId;
            } else {
                currentHighlightedRoomId = null;
            }
        }
        // --- Взаимодействие с интерфейсом ---
        function attachEventListeners() {
            // Подсветка учителя при клике на его имя в уроке
            // Используем event delegation на tbody
            document.getElementById('schedule-body').addEventListener('click', (e) => {
                if (e.target.classList.contains('teacher-name')) {
                    e.stopPropagation(); // Останавливаем всплытие, чтобы не открывалась форма редактирования
                    const teacherId = parseInt(e.target.dataset.teacherId);
                    highlightTeacher(teacherId);
                }
                // Подсветка кабинета при клике на его имя в уроке
                else if (e.target.classList.contains('room-name')) {
                    e.stopPropagation(); // Останавливаем всплытие
                    const roomId = parseInt(e.target.dataset.roomId);
                    highlightRoom(roomId);
                }
            });
            // --- ИСПРАВЛЕНО: Открытие формы редактирования/создания при клике ТОЛЬКО НА ЯЧЕЙКУ урока ---
            document.getElementById('schedule-body').addEventListener('click', (e) => {
                // Проверяем, что клик был по .lesson-cell или её потомкам, но НЕ по .teacher-name или .room-name
                const clickedLessonCell = e.target.closest('.lesson-cell');
                if (clickedLessonCell && !e.target.classList.contains('teacher-name') && !e.target.classList.contains('room-name')) {
                    // СБРОСИТЬ ПОДСВЕТКИ УЧИТЕЛЯ И КАБИНЕТА при открытии окна редактирования
                    if (currentHighlightedTeacherId !== null) {
                         highlightTeacher(null);
                    }
                    if (currentHighlightedRoomId !== null) {
                         highlightRoom(null);
                    }
                    // Получаем данные из найденной ячейки
                    const day = parseInt(clickedLessonCell.dataset.day);
                    const lessonNumber = parseInt(clickedLessonCell.dataset.lessonNumber);
                    const classId = parseInt(clickedLessonCell.dataset.classId);
                    const date = clickedLessonCell.dataset.date; // Получаем дату из ячейки
                    const originalLessonId = clickedLessonCell.dataset.originalLessonId; // ID урока из базового расписания или пусто

                    // Проверяем, есть ли внутри div.lesson-details (т.е. был ли урок)
                    // Теперь у нас может быть несколько .lesson-details
                    const lessonDetailsDivs = clickedLessonCell.querySelectorAll('.lesson-details');
                    if (lessonDetailsDivs.length > 0) {
                        // --- НОВОЕ: Если есть уроки, показываем диалог ---
                        // Если выбрана дата, показываем диалог для редактирования урока
                        if (date) {
                            // При наличии даты также открываем обычное окно редактирования
                            const lessonDiv = lessonDetailsDivs[0]; // Берём первый урок в слоте для примера
                            const lessonId = parseInt(lessonDiv.dataset.lessonId); // Используем lessonId для редактирования
                            openEditModal(lessonId, day, lessonNumber, classId);
                        } else {
                            // Если дата не выбрана, показываем старый диалог
                            showLessonOptionsDialog(clickedLessonCell, lessonDetailsDivs, day, lessonNumber, classId);
                        }
                    } else {
                        // Если div нет, значит ячейка пуста.
                        // Если выбрана дата, можно предложить создать временный урок (например, отменить или добавить).
                        // Теперь разрешаем создание уроков на пустые слоты с датой.
                        if (date) {
                            // Если дата выбрана, открываем окно создания урока на пустой слот
                            console.log("Клик на пустую ячейку с датой:", "День:", day, "Урок:", lessonNumber, "Класс:", classId, "Дата:", date);
                            openEditModal(null, day, lessonNumber, classId);
                        } else {
                            // Если дата не выбрана, открываем окно создания.
                            console.log("Клик на пустую ячейку:", "День:", day, "Урок:", lessonNumber, "Класс:", classId);
                            openEditModal(null, day, lessonNumber, classId);
                        }
                    }
                }
                // Если клик был не по .lesson-cell или по .teacher-name/.room-name, ничего не делаем.
            });
            // --- НОВОЕ: Сброс подсветки при клике в произвольное место ---
            document.addEventListener('click', (e) => {
                // Проверяем, что клик НЕ по имени учителя, НЕ по имени кабинета и НЕ внутри модального окна
                const isClickOnTeacherName = e.target.closest('.teacher-name');
                const isClickOnRoomName = e.target.closest('.room-name');
                const isClickInsideModal = e.target.closest('#edit-modal') || e.target.closest('#temp-change-modal');
                const isClickInsideSchedule = e.target.closest('#schedule-body'); // Клик внутри таблицы расписания
                // Сбрасываем подсветку только если клик был вне таблицы расписания И не по модальному окну
                // Или если клик был по таблице, но НЕ по имени учителя/кабинета
                if (!isClickInsideModal) {
                    // Если клик был по таблице, но НЕ по имени учителя или кабинета - подсветка сбросится при открытии модального окна
                    // Если клик был внутри таблицы И по имени учителя/кабинета - подсветка установится/изменится, как и задумано
                    if (!isClickInsideSchedule) {
                        // Клик был вне таблицы и вне модального окна - сбросить подсветку
                        if (currentHighlightedTeacherId !== null) {
                            highlightTeacher(null);
                        }
                        if (currentHighlightedRoomId !== null) {
                            highlightRoom(null);
                        }
                    }
                }
            });
            // Отправка команды ИИ-боту
            document.getElementById('send-button').addEventListener('click', sendCommandToBot);
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendCommandToBot();
                }
            });
            // Закрытие модального окна редактирования
            document.getElementById('cancel-edit').addEventListener('click', closeEditModal);
            document.getElementById('edit-modal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('edit-modal')) {
                    closeEditModal();
                }
            });
            // Сохранение изменений урока
            document.getElementById('edit-form').addEventListener('submit', saveLessonChanges);
            // --- НОВОЕ: Обработчики для модального окна временных изменений ---
            document.getElementById('cancel-temp-change').addEventListener('click', closeTempChangeModal);
            document.getElementById('temp-change-modal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('temp-change-modal')) {
                    closeTempChangeModal();
                }
            });
            document.getElementById('temp-change-form').addEventListener('submit', saveTempChange);
            document.getElementById('delete-temp-change').addEventListener('click', deleteTempChange);
            // --- Обработчики для типа изменения ---
            document.getElementById('temp-change-type').addEventListener('change', function() {
                const type = this.value;
                document.getElementById('substitution-fields').style.display = type === 'substitution' ? 'block' : 'none';
                document.getElementById('movement-fields').style.display = type === 'movement' ? 'block' : 'none';
            });
            // --- Обработчики для экспорта и очистки ---
            document.getElementById('export-btn').addEventListener('click', handleExport);
            document.getElementById('export-formatted-btn').addEventListener('click', handleExportFormatted); // НОВЫЙ ОБРАБОТЧИК
            document.getElementById('clear-schedule-btn').addEventListener('click', handleClearSchedule);
            document.getElementById('clear-db-btn').addEventListener('click', handleClearDatabase);
            // --- Обработчики для загрузки ---
            document.getElementById('upload-btn').addEventListener('click', handleFileUpload);
            // --- НОВОЕ: Обработчик для кнопки "Применить дату" ---
            document.getElementById('apply-date-btn').addEventListener('click', function() {
                const dateInput = document.getElementById('date-selector');
                selectedDate = dateInput.value; // Сохраняем выбранную дату
                if (selectedDate && currentShift) {
                    loadScheduleDataForDate(selectedDate, currentShift);
                } else if (!currentShift) {
                    addChatMessage("Сначала выберите смену.", 'bot');
                } else {
                    addChatMessage("Выберите дату.", 'bot');
                }
            });
            // --- НОВОЕ: Обработчик для кнопки "Постоянное расписание" ---
            document.getElementById('permanent-schedule-btn').addEventListener('click', function() {
                document.getElementById('date-selector').value = ''; // Сбрасываем выбор даты
                selectedDate = null; // Сбрасываем переменную даты
                if (currentShift) {
                    loadScheduleData(currentShift); // Перезагружаем постоянное расписание
                } else {
                    addChatMessage("Сначала выберите смену.", 'bot');
                }
            });
        }
        // --- НОВАЯ ФУНКЦИЯ: Показать диалог для выбора действия ---
        function showLessonOptionsDialog(cell, lessonDivs, day, lessonNumber, classId) {
            const lessonCount = lessonDivs.length;
            let message = `В ячейке (${getDayName(day)}, ${lessonNumber} урок, ${classesList.find(c => c.id === classId)?.name || 'N/A'}) уже есть ${lessonCount} уроков.`;
            message += "Выберите действие:";
            message += "1. Редактировать один из существующих уроков.";
            message += "2. Добавить новый урок (для другой подгруппы).";
            // Запросим действие через prompt
            let choice = prompt(message, "2"); // По умолчанию предлагаем добавить новый
            // Проверим, что пользователь нажал "OK" и ввёл значение
            if (choice === null) {
                // Пользователь нажал "Отмена"
                return; // Прерываем выполнение
            }
            // Преобразуем ввод в число
            const parsedChoice = parseInt(choice);
            if (isNaN(parsedChoice)) {
                // Введено не число
                addChatMessage("Ошибка: Введите число 1 или 2.", 'bot');
                return;
            }
            if (parsedChoice === 1) {
                // Показать список уроков и позволить выбрать ID для редактирования
                const lessonList = Array.from(lessonDivs).map((div, index) => {
                    const lessonId = div.dataset.lessonId;
                    const subjectId = parseInt(div.querySelector('.subject-name')?.dataset.subjectId || 0);
                    const teacherId = parseInt(div.querySelector('.teacher-name')?.dataset.teacherId || 0);
                    const roomId = parseInt(div.querySelector('.room-name')?.dataset.roomId || 0);
                    const subgroupId = parseInt(div.dataset.subgroupId || 0);
                    const subject = subjectsList.find(s => s.id === subjectId)?.name || 'N/A';
                    const teacher = teachersList.find(t => t.id === teacherId)?.name || 'N/A';
                    const room = roomsList.find(r => r.id === roomId)?.name || 'N/A';
                    const subgroup = subgroupsList.find(sg => sg.id === subgroupId)?.name || 'N/A';
                    return `${index + 1}. ${subject}, ${teacher}, ${room}, ${subgroup} (ID: ${lessonId})`;
                }).join('');
                const lessonToEditInput = prompt(`Выберите урок для редактирования:${lessonList}Введите номер (1-${lessonCount}) или ID урока:`);
                // Проверим, что пользователь нажал "OK" и ввёл значение
                if (lessonToEditInput === null) {
                    // Пользователь нажал "Отмена"
                    return;
                }
                let lessonIdToEdit = null;
                const parsedIndex = parseInt(lessonToEditInput);
                if (!isNaN(parsedIndex) && parsedIndex >= 1 && parsedIndex <= lessonCount) {
                    // Выбрали по номеру
                    lessonIdToEdit = parseInt(lessonDivs[parsedIndex - 1].dataset.lessonId);
                } else if (!isNaN(lessonToEditInput)) {
                    // Выбрали по ID
                    lessonIdToEdit = parseInt(lessonToEditInput);
                }
                if (lessonIdToEdit && lessonIdToEdit > 0) {
                    openEditModal(lessonIdToEdit);
                } else {
                    alert("Неверный выбор урока для редактирования.");
                }
            } else if (parsedChoice === 2) {
                // Открыть окно для создания нового урока в этом слоте
                openEditModal(null, day, lessonNumber, classId);
            } else {
                // Введено число, отличное от 1 или 2
                addChatMessage("Ошибка: Введите число 1 или 2.", 'bot');
            }
        }
        // --- ОБНОВЛЁННАЯ ФУНКЦИЯ: Форма редактирования ---
        async function openEditModal(lessonId, day = null, lessonNumber = null, classId = null) {
            // СБРОСИТЬ ПОДСВЕТКИ УЧИТЕЛЯ И КАБИНЕТА при открытии окна редактирования
            if (currentHighlightedTeacherId !== null) {
                 highlightTeacher(null);
            }
            if (currentHighlightedRoomId !== null) {
                 highlightRoom(null);
            }
            let lesson = null;
            if (lessonId) {
                lesson = scheduleData.find(l => l.id === lessonId);
                if (!lesson) return;
            }
            document.getElementById('edit-lesson-id').value = lessonId || '';
            // Определяем classId для ячейки, для которой открываем окно
            let targetClassId = null;
            if (lesson) {
                // Если редактируем урок, получаем classId из подгруппы урока
                const subgroup = subgroupsList.find(sg => sg.id === lesson.subgroup_id);
                if (subgroup) {
                    targetClassId = subgroup.class_id;
                }
            } else if (classId !== null) {
                // Если создаём урок, classId передаётся как параметр
                targetClassId = classId;
            }
            if (targetClassId) {
                // Найти все подгруппы для targetClassId
                const allSubgroupsForClass = subgroupsList.filter(sg => sg.class_id === targetClassId);
                // --- НОВОЕ: Установить currentClassId ---
                currentClassId = targetClassId;
                if (lesson) {
                    // Режим редактирования
                    // Заполнить выпадающие списки (предполагается, что они уже загружены)
                    populateSelect('edit-subject', subjectsList, lesson.subject_id);
                    populateSelect('edit-teacher', teachersList, lesson.teacher_id);
                    // Заполнить подгруппы, отфильтрованные по classId
                    populateSelect('edit-subgroup', allSubgroupsForClass, lesson.subgroup_id);
                    populateSelect('edit-room', roomsList, lesson.room_id);
                    // Заполнить день и урок
                    document.getElementById('edit-day').value = lesson.day_of_week;
                    document.getElementById('edit-slot').value = lesson.lesson_number;
                } else {
                    // Режим создания
                    // Заполняем день и урок из параметров
                    if (day !== null) {
                        document.getElementById('edit-day').value = day;
                    }
                    if (lessonNumber !== null) {
                        document.getElementById('edit-slot').value = lessonNumber;
                    }
                    // --- НОВОЕ: Фильтрация предметов и учителей для класса ---
                    try {
                        // 1. Загрузка отфильтрованных предметов для выбранного класса
                        const classSubjectsResponse = await fetch(`/api/class_subjects/${targetClassId}`);
                        if (!classSubjectsResponse.ok) {
                            throw new Error(`Ошибка API для предметов класса: ${classSubjectsResponse.status}`);
                        }
                        const filteredSubjects = await classSubjectsResponse.json();
                        populateSelect('edit-subject', filteredSubjects, null); // Не выбираем предмет по умолчанию
                        // 2. Загрузка отфильтрованных учителей для выбранного класса
                        const classTeachersResponse = await fetch(`/api/class_teachers/${targetClassId}`);
                        if (!classTeachersResponse.ok) {
                            throw new Error(`Ошибка API для учителей класса: ${classTeachersResponse.status}`);
                        }
                        const filteredTeachers = await classTeachersResponse.json();
                        populateSelect('edit-teacher', filteredTeachers, null); // Не выбираем учителя по умолчанию
                        // 3. Заполнить подгруппы, отфильтрованные по classId
                        // Сначала заполняем пустым списком или списком всех подгрупп, если предмет не выбран
                        populateSelect('edit-subgroup', allSubgroupsForClass, null);
                        // 4. Заполнить кабинеты (все доступные)
                        populateSelect('edit-room', roomsList, null);
                    } catch (error) {
                        console.error('Ошибка при загрузке отфильтрованных данных для класса:', error);
                        addChatMessage(`Ошибка при загрузке данных для класса: ${error.message}`, 'bot');
                        // В случае ошибки, можно заполнить списками по умолчанию
                        populateSelect('edit-subject', subjectsList, null);
                        populateSelect('edit-teacher', teachersList, null);
                        populateSelect('edit-subgroup', allSubgroupsForClass, null);
                        populateSelect('edit-room', roomsList, null);
                    }
                }
            } else {
                // Это ошибка - не удалось определить classId
                console.error("Не удалось определить classId для открытия модального окна.");
                addChatMessage("Ошибка: Не удалось определить класс для новой ячейки.", 'bot');
                return; // Прерываем выполнение, если classId неизвестен
            }
            document.getElementById('edit-modal').style.display = 'block';
            // --- НОВОЕ: Добавляем обработчики изменения предмета и подгруппы ---
            setupSubjectTeacherLink(); // Устанавливаем обработчик для предмета -> учителя
            setupSubjectSubgroupLink(); // Устанавливаем обработчик для предмета -> подгруппы
        }
        // --- НОВАЯ ФУНКЦИЯ: Устанавливает связь между выбором предмета и учителя ---
        function setupSubjectTeacherLink() {
            const subjectSelect = document.getElementById('edit-subject');
            const teacherSelect = document.getElementById('edit-teacher');
            subjectSelect.addEventListener('change', async (e) => { // Сделаем асинхронным
                const selectedSubjectId = parseInt(e.target.value);
                // Фильтруем учителей на основе выбранного предмета и currentClassId
                if (!selectedSubjectId || !currentClassId) {
                    // Если предмет или classId не выбраны, сбросить список учителей
                    // Попробуем снова загрузить учителей для класса, без фильтрации по предмету
                    try {
                        const classTeachersResponse = await fetch(`/api/class_teachers/${currentClassId}`);
                        if (!classTeachersResponse.ok) {
                            throw new Error(`Ошибка API для учителей класса: ${classTeachersResponse.status}`);
                        }
                        const filteredTeachers = await classTeachersResponse.json();
                        populateSelect('edit-teacher', filteredTeachers, null);
                    } catch (error) {
                        console.error('Ошибка при загрузке учителей класса:', error);
                        populateSelect('edit-teacher', teachersList, null); // Возврат к общему списку
                    }
                    return;
                }
                // Загрузка учителей, которые могут вести *выбранный* предмет в *данном* классе
                try {
                    const classTeachersForSubjectResponse = await fetch(`/api/class_teachers_for_subject/${currentClassId}/${selectedSubjectId}`);
                    if (!classTeachersForSubjectResponse.ok) {
                        throw new Error(`Ошибка API для учителей класса по предмету: ${classTeachersForSubjectResponse.status}`);
                    }
                    const filteredTeachers = await classTeachersForSubjectResponse.json();
                    populateSelect('edit-teacher', filteredTeachers, null);
                } catch (error) {
                    console.error('Ошибка при загрузке учителей для класса и предмета:', error);
                    addChatMessage(`Ошибка при фильтрации учителей: ${error.message}`, 'bot');
                    // В случае ошибки, можно заполнить списком учителей для класса (без фильтрации по предмету)
                    try {
                        const classTeachersResponse = await fetch(`/api/class_teachers/${currentClassId}`);
                        if (!classTeachersResponse.ok) {
                            throw new Error(`Ошибка API для учителей класса: ${classTeachersResponse.status}`);
                        }
                        const fallbackTeachers = await classTeachersResponse.json();
                        populateSelect('edit-teacher', fallbackTeachers, null);
                    } catch (fallbackError) {
                        console.error('Ошибка при возврате к учителям класса:', fallbackError);
                        populateSelect('edit-teacher', teachersList, null); // Возврат к общему списку
                    }
                }
            });
        }
        // --- НОВАЯ ФУНКЦИЯ: Устанавливает связь между выбором предмета и подгруппы ---
        function setupSubjectSubgroupLink() {
            const subjectSelect = document.getElementById('edit-subject');
            const subgroupSelect = document.getElementById('edit-subgroup');
            subjectSelect.addEventListener('change', (e) => {
                const selectedSubjectId = parseInt(e.target.value);
                if (!selectedSubjectId || !currentClassId) {
                    // Если предмет не выбран или classId неизвестен, сбросить список подгрупп
                    const allSubgroupsForClass = subgroupsList.filter(sg => sg.class_id === currentClassId);
                    populateSelect('edit-subgroup', allSubgroupsForClass, null);
                    return;
                }
                // Найти требование по предмету и классу
                const requirement = classSubjectRequirementsList.find(req => req.class_id === currentClassId && req.subject_id === selectedSubjectId);
                if (requirement) {
                    // Если есть требование, и оно больше 1, значит, вероятно, нужно использовать подгруппы
                    // (это эвристика, в идеале было бы поле в ClassSubjectRequirement, указывающее на необходимость подгрупп)
                    // Для простоты, если требование > 1, покажем все подгруппы
                    // Если требование = 1, покажем "нет" или "весь класс" и подгруппы не выбирать
                    // Или, если в классе есть подгруппы, и предмет требует > 1 часа, покажем подгруппы.
                    // Или, если в системе уже есть уроки для разных подгрупп по этому предмету.
                    // Упрощённый подход: если предмет в классе существует (т.е. есть ClassSubjectRequirement), и в классе есть подгруппы > 1, покажем подгруппы.
                    // Более точный подход: проверить, есть ли в ClassSubjectRequirement или TeacherSubjectRequirement указание на то, что предмет идёт по подгруппам.
                    // Пока реализуем упрощённо: если в классе больше 1 подгруппы, покажем все подгруппы. Если 1, покажем её или "весь класс".
                    const allSubgroupsForClass = subgroupsList.filter(sg => sg.class_id === currentClassId); // Уже отфильтрованы по classId
                    const hasMultipleSubgroups = allSubgroupsForClass.length > 1;
                    if (hasMultipleSubgroups) {
                        // Показываем все подгруппы класса
                        populateSelect('edit-subgroup', allSubgroupsForClass, null);
                    } else {
                        // Показываем "нет" или "весь класс" и первую (и единственную) подгруппу как вариант "класс"
                        // Или, если в классе только одна подгруппа, просто покажем её.
                        // Для простоты, если подгруппа одна, просто покажем её.
                        // Если подгрупп нет, покажем пустой список или "нет подгрупп".
                        populateSelect('edit-subgroup', allSubgroupsForClass, null);
                    }
                } else {
                    // Если требования по предмету нет, покажем все подгруппы (или "нет" как вариант)
                    // Для простоты, если нет требования, всё равно покажем подгруппы класса.
                    // Но можно добавить "нет" как опцию, если предмет не планируется в классе.
                    // Пока оставим как есть - показываем подгруппы класса.
                    const allSubgroupsForClass = subgroupsList.filter(sg => sg.class_id === currentClassId);
                    populateSelect('edit-subgroup', allSubgroupsForClass, null);
                }
            });
        }
        // --- ОБНОВЛЁННАЯ функция populateSelect ---
        function populateSelect(elementId, list, selectedId) {
            const selectElement = document.getElementById(elementId);
            selectElement.innerHTML = ''; // Очистить
            list.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                option.textContent = item.name;
                if (item.id === selectedId) {
                    option.selected = true;
                }
                selectElement.appendChild(option);
            });
            // Если список пуст, добавим одну опцию "Нет доступных"
            if (list.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Нет доступных';
                option.disabled = true; // Сделать неактивным
                selectElement.appendChild(option);
            }
        }
        function closeEditModal() {
            document.getElementById('edit-modal').style.display = 'none';
        }
        async function saveLessonChanges(e) {
            e.preventDefault();
            const lessonIdInput = document.getElementById('edit-lesson-id');
            const lessonIdValue = lessonIdInput.value.trim();
            const isCreating = lessonIdValue === '';
            const updatedLessonData = {
                subject_id: parseInt(document.getElementById('edit-subject').value),
                teacher_id: parseInt(document.getElementById('edit-teacher').value),
                subgroup_id: parseInt(document.getElementById('edit-subgroup').value), // ID подгруппы теперь всегда из отфильтрованного списка
                room_id: parseInt(document.getElementById('edit-room').value),
                day_of_week: parseInt(document.getElementById('edit-day').value),
                lesson_number: parseInt(document.getElementById('edit-slot').value)
            };
            // Проверим, что subgroup_id выбран (если это обязательное поле)
            if (isNaN(updatedLessonData.subgroup_id) || updatedLessonData.subgroup_id <= 0) {
                addChatMessage("Ошибка: Не выбрана подгруппа.", 'bot');
                return;
            }
            let response;
            let successMessage;
            let errorMessage;
            try {
                if (isCreating) {
                    // Режим создания: отправляем POST на /api/lessons
                    response = await fetch('/api/lessons', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedLessonData),
                    });
                    successMessage = 'Урок успешно создан';
                    errorMessage = 'Ошибка создания урока';
                } else {
                    // Режим редактирования: отправляем PUT на /api/lessons/{id}
                    const lessonId = parseInt(lessonIdValue);
                    if (isNaN(lessonId)) {
                         throw new Error("ID урока не является числом.");
                    }
                    response = await fetch(`/api/lessons/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedLessonData),
                    });
                    successMessage = 'Урок успешно обновлён';
                    errorMessage = 'Ошибка обновления урока';
                }
                if (response.ok) {
                    const result = await response.json();
                    addChatMessage(result.message, 'bot');
                    closeEditModal();
                    // Перезагрузить данные или обновить локально
                    if (selectedDate && currentShift) {
                        loadScheduleDataForDate(selectedDate, currentShift); // Перезагружаем для выбранной даты и смены
                    } else if (currentShift) {
                        loadScheduleData(currentShift); // Перезагружаем для выбранной смены
                    }
                } else {
                    const errorResult = await response.json();
                    addChatMessage(`Ошибка: ${errorResult.error || 'Неизвестная ошибка'}`, 'bot');
                }
            } catch (error) {
                console.error(`Ошибка при ${isCreating ? 'создании' : 'обновлении'} урока:`, error);
                addChatMessage(`Ошибка: ${error.message}`, 'bot');
            }
        }
        // --- НОВАЯ ФУНКЦИЯ: Открытие модального окна для временных изменений ---
        async function openTempChangeModal(lessonId, date) {
            if (!lessonId || !date) {
                addChatMessage("Не передан ID урока или дата для изменения.", 'bot');
                return;
            }
            // СБРОСИТЬ ПОДСВЕТКИ УЧИТЕЛЯ И КАБИНЕТА при открытии окна редактирования
            if (currentHighlightedTeacherId !== null) {
                 highlightTeacher(null);
            }
            if (currentHighlightedRoomId !== null) {
                 highlightRoom(null);
            }

            document.getElementById('temp-change-lesson-id').value = lessonId;
            document.getElementById('temp-change-date').value = date;

            // Загрузим временные изменения для этого урока и даты, если они есть
            const existingChange = temporaryChangesData.find(change => change.original_lesson_id === lessonId && change.date === date);

            if (existingChange) {
                // Заполняем форму данными существующего изменения
                document.getElementById('temp-change-type').value = existingChange.change_type;
                document.getElementById('temp-change-reason').value = existingChange.reason || '';

                if (existingChange.change_type === 'substitution' && existingChange.new_teacher_id) {
                    // Загрузим учителей для выбора
                    populateSelect('temp-change-new-teacher', teachersList, existingChange.new_teacher_id);
                    document.getElementById('substitution-fields').style.display = 'block';
                } else if (existingChange.change_type === 'movement') {
                    document.getElementById('temp-change-new-day').value = existingChange.new_day_of_week !== undefined ? existingChange.new_day_of_week : '';
                    document.getElementById('temp-change-new-slot').value = existingChange.new_lesson_number !== undefined ? existingChange.new_lesson_number : '';
                    populateSelect('temp-change-new-room', roomsList, existingChange.new_room_id);
                    document.getElementById('movement-fields').style.display = 'block';
                }
            } else {
                // Новое изменение - сбросим поля
                document.getElementById('temp-change-type').value = '';
                document.getElementById('temp-change-reason').value = '';
                document.getElementById('substitution-fields').style.display = 'none';
                document.getElementById('movement-fields').style.display = 'none';
                // Загрузим учителей и кабинеты для выбора (если потребуется)
                populateSelect('temp-change-new-teacher', teachersList, null);
                populateSelect('temp-change-new-room', roomsList, null);
            }

            document.getElementById('temp-change-modal').style.display = 'block';
        }
        // --- НОВАЯ ФУНКЦИЯ: Закрытие модального окна для временных изменений ---
        function closeTempChangeModal() {
            document.getElementById('temp-change-modal').style.display = 'none';
        }
        // --- НОВАЯ ФУНКЦИЯ: Сохранение временного изменения ---
        async function saveTempChange(e) {
            e.preventDefault();
            const lessonId = parseInt(document.getElementById('temp-change-lesson-id').value);
            const date = document.getElementById('temp-change-date').value;
            const changeType = document.getElementById('temp-change-type').value;
            const reason = document.getElementById('temp-change-reason').value;

            if (!lessonId || !date || !changeType) {
                addChatMessage("Не переданы обязательные параметры для изменения.", 'bot');
                return;
            }

            const changeData = {
                original_lesson_id: lessonId,
                date: date,
                change_type: changeType,
                reason: reason
            };

            if (changeType === 'substitution') {
                changeData.new_teacher_id = parseInt(document.getElementById('temp-change-new-teacher').value);
                if (isNaN(changeData.new_teacher_id)) {
                    addChatMessage("Для замены учителя выберите нового учителя.", 'bot');
                    return;
                }
            } else if (changeType === 'movement') {
                changeData.new_day_of_week = parseInt(document.getElementById('temp-change-new-day').value);
                changeData.new_lesson_number = parseInt(document.getElementById('temp-change-new-slot').value);
                changeData.new_room_id = parseInt(document.getElementById('temp-change-new-room').value);
                if (isNaN(changeData.new_day_of_week) || isNaN(changeData.new_lesson_number) || isNaN(changeData.new_room_id)) {
                    addChatMessage("Для переноса урока заполните день, урок и кабинет.", 'bot');
                    return;
                }
            }
            // Для отмены (cancellation) не требуем дополнительных полей

            try {
                // Проверим, существует ли уже изменение для этого урока и даты
                const existingChange = temporaryChangesData.find(change => change.original_lesson_id === lessonId && change.date === date);
                let response;
                let successMessage;
                let errorMessage;
                if (existingChange) {
                    // Обновляем существующее изменение
                    // Используем PUT к конкретному ID изменения, если API поддерживает
                    // Или используем DELETE + POST, как в текущем API
                    // Предположим, API поддерживает POST с тем же original_lesson_id и date - он обновит
                    response = await fetch('/api/temporary_changes', {
                        method: 'POST', // Используем POST, так как API не имеет PUT
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(changeData),
                    });
                    successMessage = 'Временное изменение успешно обновлено';
                    errorMessage = 'Ошибка обновления временного изменения';
                } else {
                    // Создаём новое изменение
                    response = await fetch('/api/temporary_changes', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(changeData),
                    });
                    successMessage = 'Временное изменение успешно создано';
                    errorMessage = 'Ошибка создания временного изменения';
                }

                if (response.ok) {
                    const result = await response.json();
                    addChatMessage(result.message, 'bot');
                    closeTempChangeModal();
                    // Перезагрузить данные
                    if (selectedDate && currentShift) {
                        loadScheduleDataForDate(selectedDate, currentShift); // Перезагружаем для выбранной даты и смены
                    }
                } else {
                    const errorResult = await response.json();
                    addChatMessage(`Ошибка: ${errorResult.error || 'Неизвестная ошибка'}`, 'bot');
                }
            } catch (error) {
                console.error(`Ошибка при сохранении временного изменения:`, error);
                addChatMessage(`Ошибка: ${error.message}`, 'bot');
            }
        }
        // --- НОВАЯ ФУНКЦИЯ: Удаление временного изменения ---
        async function deleteTempChange() {
            const lessonId = parseInt(document.getElementById('temp-change-lesson-id').value);
            const date = document.getElementById('temp-change-date').value;

            if (!lessonId || !date) {
                addChatMessage("Не переданы ID урока или дата для удаления изменения.", 'bot');
                return;
            }

            const confirmation = confirm(`Вы уверены, что хотите удалить временное изменение для урока ${lessonId} на дату ${date}?`);
            if (!confirmation) {
                return;
            }

            try {
                // Найдем ID записи изменения в базе данных
                const changeToDelete = temporaryChangesData.find(change => change.original_lesson_id === lessonId && change.date === date);
                if (!changeToDelete) {
                    addChatMessage("Запись для удаления не найдена.", 'bot');
                    return;
                }
                const changeId = changeToDelete.id;
                const response = await fetch(`/api/temporary_changes/${changeId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (response.ok) {
                    const result = await response.json();
                    addChatMessage(result.message, 'bot');
                    closeTempChangeModal();
                    // Перезагрузить данные
                    if (selectedDate && currentShift) {
                        loadScheduleDataForDate(selectedDate, currentShift); // Перезагружаем для выбранной даты и смены
                    }
                } else {
                    const errorResult = await response.json();
                    addChatMessage(`Ошибка: ${errorResult.error || 'Неизвестная ошибка'}`, 'bot');
                }
            } catch (error) {
                console.error(`Ошибка при удалении временного изменения:`, error);
                addChatMessage(`Ошибка: ${error.message}`, 'bot');
            }
        }
        // --- Загрузка файлов ---
        async function handleFileUpload() {
            const fileHoursInput = document.getElementById('file-hours');
            const fileTeachersInput = document.getElementById('file-teachers');
            const statusDiv = document.getElementById('upload-status');
            const fileHours = fileHoursInput.files[0];
            const fileTeachers = fileTeachersInput.files[0];
            if (!fileHours || !fileTeachers) {
                statusDiv.textContent = 'Пожалуйста, выберите оба файла.';
                statusDiv.style.color = 'red';
                return;
            }
            // Простая проверка типа файла (опционально)
            if (!fileHours.name.endsWith('.xlsx') && !fileHours.name.endsWith('.xls')) {
                statusDiv.textContent = 'Файл часов должен быть .xlsx или .xls';
                statusDiv.style.color = 'red';
                return;
            }
            if (!fileTeachers.name.endsWith('.xlsx') && !fileTeachers.name.endsWith('.xls')) {
                statusDiv.textContent = 'Файл нагрузки должен быть .xlsx или .xls';
                statusDiv.style.color = 'red';
                return;
            }
            statusDiv.textContent = 'Загрузка...';
            statusDiv.style.color = 'orange';
            const formData = new FormData();
            formData.append('file_hours', fileHours);
            formData.append('file_teachers', fileTeachers);
            try {
                const response = await fetch('/upload_data', {
                    method: 'POST',
                    body: formData, // Используем FormData для отправки файлов
                });
                const result = await response.json();
                if (response.ok) {
                    statusDiv.textContent = result.message;
                    statusDiv.style.color = 'green';
                    // Возможно, стоит перезагрузить список классов/уроков, если это влияет на отображение
                    // loadShifts(); // Если смены/классы могли измениться
                    if (currentShift) {
                        loadScheduleData(currentShift); // Перезагружаем расписание для текущей смены
                    }
                } else {
                    statusDiv.textContent = `Ошибка: ${result.error}`;
                    statusDiv.style.color = 'red';
                }
            } catch (error) {
                console.error('Ошибка при отправке команды боту:', error);
                statusDiv.textContent = `Ошибка сети: ${error.message}`, 'bot';
                statusDiv.style.color = 'red';
            }
        }
        function addChatMessage(text, sender) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            messageElement.textContent = text;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight; // Прокрутка вниз
        }
        // --- Чат-бот ---
        async function sendCommandToBot() {
            const inputElement = document.getElementById('chat-input');
            const command = inputElement.value.trim();
            if (!command) return;
            addChatMessage(command, 'user');
            inputElement.value = '';
            // Пример обработки команды, зависящей от смены
            // Пока просто передаём как есть, но логика ИИ может учитывать смену
            // В заглушке мы этого не моделируем, но бэкенд может
            try {
                const response = await fetch('/api/ai_command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ command: command }),
                });
                const data = await response.json();
                if (response.ok) {
                    // Показать ответ ИИ
                    let botResponse = `Команда обработана. Действие: ${data.action}.`;
                    if (data.action === 'found_replacements') {
                        botResponse = `Найдены возможные замены для урока ${data.lesson_id}:`;
                        data.possible_replacements.forEach(rep => {
                            botResponse += `- ${rep.teacher_name} (ID: ${rep.teacher_id})`;
                        });
                    } else if (data.action === 'lesson_moved') {
                        botResponse = data.details.message;
                    } else if (data.action === 'suggested_slots') {
                        botResponse = "Найдены свободные слоты:";
                        data.details.slots.forEach(slot => {
                            botResponse += `- День: ${getDayName(slot.day)}, Урок: ${slot.slot}, Учитель ID: ${slot.teacher_id}, Кабинет ID: ${slot.room_id}`;
                        });
                    } else if (data.details && data.details.error_message) {
                        botResponse = `Ошибка ИИ: ${data.details.error_message}`;
                    } else if (data.details && data.details.message) {
                         botResponse = data.details.message;
                    }
                    addChatMessage(botResponse, 'bot');
                    // Если действие ИИ повлияло на расписание, возможно, стоит перезагрузить его
                    if (['lesson_moved', 'lesson_added', 'lesson_removed'].includes(data.action)) {
                        if (selectedDate && currentShift) {
                            loadScheduleDataForDate(selectedDate, currentShift); // Перезагружаем для выбранной даты и смены
                        } else if (currentShift) {
                            loadScheduleData(currentShift); // Перезагружаем для выбранной смены
                        }
                    }
                } else {
                    addChatMessage(`Ошибка от бота: ${data.error || 'Неизвестная ошибка'}`, 'bot');
                }
            } catch (error) {
                console.error('Ошибка при отправке команды боту:', error);
                addChatMessage(`Ошибка связи с ботом: ${error.message}`, 'bot');
            }
        }
        // --- Функции экспорта и очистки ---
        async function handleExport() {
            if (!currentShift) {
                addChatMessage("Выберите смену для экспорта.", 'bot');
                return;
            }
            try {
                // Используем window.location.href для скачивания файла
                window.location.href = `/export_schedule?shift=${currentShift}`;
                addChatMessage("Файл экспортируется (список)...", 'bot');
            } catch (error) {
                console.error('Ошибка при экспорте:', error);
                addChatMessage(`Ошибка экспорта: ${error.message}`, 'bot');
            }
        }
        // --- НОВАЯ ФУНКЦИЯ ---
        async function handleExportFormatted() {
            if (!currentShift) {
                addChatMessage("Выберите смену для экспорта.", 'bot');
                return;
            }
            try {
                // Используем window.location.href для скачивания файла
                window.location.href = `/export_schedule_formatted?shift=${currentShift}`;
                addChatMessage("Файл экспортируется (таблица)...", 'bot');
            } catch (error) {
                console.error('Ошибка при форматированном экспорте:', error);
                addChatMessage(`Ошибка форматированного экспорта: ${error.message}`, 'bot');
            }
        }
        async function handleClearSchedule() {
            if (!currentShift) {
                addChatMessage("Выберите смену для очистки.", 'bot');
                return;
            }
            // Проверим, выбрана ли дата. Если да, предупредим.
            if (selectedDate) {
                const confirmation = confirm(`Вы выбрали дату (${selectedDate}). Очистка смены удалит ТОЛЬКО БАЗОВОЕ расписание для смены ${currentShift}, а не временные изменения на эту дату. Продолжить?`);
                if (!confirmation) {
                    return;
                }
            } else {
                const confirmation = confirm(`Вы уверены, что хотите удалить ВСЕ БАЗОВЫЕ уроки для смены ${currentShift}? Это повлияет на постоянное расписание.`);
                if (!confirmation) {
                    return;
                }
            }

            try {
                const response = await fetch('/clear_schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ shift_id: currentShift }),
                });
                const data = await response.json();
                if (response.ok) {
                    addChatMessage(data.message, 'bot');
                    // После очистки базового расписания, перезагрузим его.
                    // Если была выбрана дата, перезагружаем базовое расписание для смены
                    // (это покажет пустые слоты, на которые могли быть наложены временные изменения).
                    // Если дата не выбрана, просто перезагружаем базовое расписание.
                    loadScheduleData(currentShift);
                    // Если дата была выбрана, оставим её выбранной, но обновим данные.
                    // В `loadScheduleData` `temporaryChangesData` будет очищен.
                    // При следующем клике на "Применить дату", временные изменения будут загружены снова.
                } else {
                    addChatMessage(`Ошибка: ${data.error}`, 'bot');
                }
            } catch (error) {
                console.error('Ошибка при очистке расписания:', error);
                addChatMessage(`Ошибка связи: ${error.message}`, 'bot');
            }
        }
        async function handleClearDatabase() {
            const confirmation = confirm("Вы уверены, что хотите удалить ВСЕ данные из базы данных? Это действие необратимо.");
            if (!confirmation) {
                return;
            }
            try {
                const response = await fetch('/clear_database', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();
                if (response.ok) {
                    addChatMessage(data.message, 'bot');
                    // После очистки БД, обновим интерфейс
                    scheduleData = [];
                    temporaryChangesData = []; // Очистим и временные изменения
                    teachersList = [];
                    subjectsList = [];
                    classesList = [];
                    subgroupsList = [];
                    roomsList = [];
                    renderSchedule(); // Очистит таблицу
                    document.getElementById('shift-selector').value = ''; // Сбросим выбор смены
                    document.getElementById('date-selector').value = ''; // Сбросим выбор даты
                    currentShift = null;
                    selectedDate = null; // Сбросим выбранную дату
                } else {
                    addChatMessage(`Ошибка: ${data.error}`, 'bot');
                }
            } catch (error) {
                console.error('Ошибка при очистке БД:', error);
                addChatMessage(`Ошибка связи: ${error.message}`, 'bot');
            }
        }
        // --- Инициализация ---
        document.addEventListener('DOMContentLoaded', () => {
            loadShifts(); // Сначала загружаем список смен
        });
    </script>
</body>
</html>