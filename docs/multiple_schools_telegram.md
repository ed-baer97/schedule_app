# Ситуация с несколькими школами одновременно

## Текущая архитектура

### ✅ Что работает хорошо:

1. **База данных (SQLite)**
   - Каждая школа имеет свою БД (`school_1.db`, `school_2.db`, и т.д.)
   - SQLite может обрабатывать **неограниченное количество школ параллельно**
   - Каждая БД изолирована, нет конфликтов
   - Чтение из разных БД происходит независимо

2. **Изоляция данных**
   - Каждая школа работает только со своей БД
   - `school_db_context` правильно переключает контекст
   - Нет смешивания данных между школами

### ⚠️ Проблема: Общий Telegram бот

**Все школы используют ОДИН и тот же Telegram бот:**
- Один `TELEGRAM_BOT_TOKEN` для всех школ
- Telegram API видит все запросы как от одного бота
- **Rate limits общие для всех школ**

## Проблемы при одновременной отправке

### Сценарий: 3 школы отправляют одновременно

```
Школа 1: 50 учителей → 50 запросов к Telegram API
Школа 2: 80 учителей → 80 запросов к Telegram API  
Школа 3: 100 учителей → 100 запросов к Telegram API
─────────────────────────────────────────────────
ИТОГО: 230 запросов одновременно
```

### Telegram API Rate Limits:
- **20-30 сообщений в секунду** на один бот
- При превышении → ошибка **429 (Too Many Requests)**
- Все школы получат ошибки одновременно

### Что произойдет:

1. **Первые 20-30 сообщений** отправятся успешно
2. **Остальные** получат ошибку 429
3. **Все школы** пострадают одновременно
4. Нужно ждать **60+ секунд** перед повторной попыткой

## Решения

### Вариант 1: Глобальная очередь (Рекомендуется)

Создать единую очередь для всех школ:

```python
# Глобальная очередь отправки
telegram_queue = Queue()

# Все школы добавляют сообщения в очередь
# Один воркер отправляет с соблюдением rate limits
```

**Преимущества:**
- ✅ Соблюдение rate limits
- ✅ Справедливое распределение между школами
- ✅ Нет конфликтов

**Недостатки:**
- ⚠️ Нужна дополнительная инфраструктура (Redis, Celery)
- ⚠️ Задержки при большой нагрузке

### Вариант 2: Задержки между школами

Добавить случайные задержки при старте рассылки:

```python
import random
import time

# Случайная задержка 0-5 секунд перед началом рассылки
time.sleep(random.uniform(0, 5))
```

**Преимущества:**
- ✅ Простая реализация
- ✅ Снижает вероятность одновременной отправки

**Недостатки:**
- ⚠️ Не гарантирует отсутствие конфликтов
- ⚠️ При большом количестве школ все равно будут конфликты

### Вариант 3: Отдельные боты для школ

Каждая школа использует свой Telegram бот:

```python
# В config.py для каждой школы
SCHOOL_TELEGRAM_TOKENS = {
    1: 'token_for_school_1',
    2: 'token_for_school_2',
    3: 'token_for_school_3',
}
```

**Преимущества:**
- ✅ Полная изоляция
- ✅ Каждая школа имеет свои rate limits
- ✅ Нет конфликтов

**Недостатки:**
- ⚠️ Нужно создавать отдельного бота для каждой школы
- ⚠️ Сложнее управление

### Вариант 4: Обработка rate limits (Текущее улучшение)

Добавить обработку ошибок 429:

```python
if response.status_code == 429:
    retry_after = int(response.headers.get('Retry-After', 60))
    time.sleep(retry_after)
    # Повторить отправку
```

**Преимущества:**
- ✅ Простая реализация
- ✅ Автоматическая обработка ошибок

**Недостатки:**
- ⚠️ Задержки при ошибках
- ⚠️ Не предотвращает конфликты, только обрабатывает их

## Рекомендации

### Для малого количества школ (2-5):
✅ **Вариант 4** (обработка rate limits) + небольшие задержки
- Просто реализовать
- Достаточно для небольшого количества школ

### Для среднего количества школ (5-20):
✅ **Вариант 1** (глобальная очередь)
- Использовать Celery или Redis Queue
- Гарантирует соблюдение rate limits

### Для большого количества школ (20+):
✅ **Вариант 3** (отдельные боты) + **Вариант 1** (очередь)
- Каждая школа со своим ботом
- Внутри каждой школы - очередь

## Практические лимиты

| Школ одновременно | Учителей всего | Статус |
|-------------------|----------------|--------|
| 1-2               | До 100         | ✅ OK  |
| 3-5               | 100-300        | ⚠️ Риск конфликтов |
| 5-10              | 300-1000       | ❌ Высокий риск |
| 10+               | 1000+          | ❌ Требуется очередь |

## Вывод

**База данных справляется отлично** - SQLite легко обрабатывает множество школ параллельно.

**Проблема в Telegram API** - все школы используют один бот, rate limits общие.

**Решение:** Добавить глобальную очередь или обработку rate limits с повторными попытками.

